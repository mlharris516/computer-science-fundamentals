1. Using proper pseudo-code, describe the following primitive algorithms:

    MAKING COFFEE

    FUNCTION makeCoffee
        IF coffee beans whole
            CALL grindCoffeeBeans
        END IF
        ADD water to kettle
        SET kettle to on
        IF waterBoiling
            SET kettle to off
        END IF
        ADD coffee beans to french press
        ADD water to french press
        IF waitTime >= 5 min 
            SERVE coffee
        ELSE wait
    END FUNCTION


    WASHING DISHES

    FUNCTION washDishes
        IF dishDirty = true
            CALL addToDishwasher
        
        IF dishwasherFull = true
            CALL addDetergent
            CALL startDishwasher
    END FUNCTION


    PROCESS FLORAL SHIPMENT

    FUNCTION processFloral
        IF newFLoral = true 
            CALL fillBuckets
        
        IF filledBuckets = true
            CALL chopStems
            ADD floral to buckets
    END FUNCTION
    


2. As with the knot algorithm, there may be more than one way to solve the problem. It is essential to try to pick the best algorithm for a situation. Name three companies who created an algorithm that made them successful, e.g., Google's search algorithm. It doesn't need to be a tech example (such as a recipe or manufacturing a product). Google's algorithm produces more relevant results than other search engines; what about each of your cases make them stand out?

    Spotify - created a platform for affordable music with easy to use software and almost limitless musical options.

    Modern 3-point seat belt by Nils Bohlin - invented a much safer and more effective seat belt, which was later available for all manufacturers to use, ultimately saving many more lives.

    Waze - a maps-like app, but better solves the everyday problem of cutting the time down on a driving destination, not just choosing the shortest distance. 


3. Hypothesize about what constitutes an efficient algorithm versus an inefficient algorithm.

An efficient algorithm would need to solve a problem, in as few steps as possible, and could possibly be used repeatedly. In contrast, I imagine an inefficient algorithm would spend too much time working a problem, or might only have limited use.